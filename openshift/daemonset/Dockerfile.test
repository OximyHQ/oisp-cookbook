# Test Dockerfile for OpenShift DaemonSet deployment
#
# This test builds the sensor, and runs the OpenShift deployment test.
# Uses k3d for testing (MicroShift is too heavy for CI).
#
# Two modes:
# 1. CI mode: k3d runs on host, this container mounts docker socket & kubeconfig
# 2. Local mode: Can run with DinD for local testing
#
# Prerequisites:
#   Clone with submodules: git clone --recurse-submodules <repo>
#   Or init after clone: git submodule update --init --recursive

# =============================================================================
# Stage 1: Build sslsniff (libbpf-based C binary)
# =============================================================================
FROM debian:bookworm-slim AS libbpf-builder

RUN apt-get update && apt-get install -y \
    build-essential \
    pkg-config \
    clang \
    llvm \
    libelf-dev \
    zlib1g-dev \
    make \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /build

COPY oisp-sensor/bpftool ./bpftool
COPY oisp-sensor/bpf ./bpf
COPY oisp-sensor/vmlinux ./vmlinux

RUN cd bpftool/src && make -j$(nproc)

WORKDIR /build/bpf
RUN LIBBPF_SRC=/build/bpftool/libbpf/src \
    BPFTOOL_SRC=/build/bpftool/src \
    VMLINUX_DIR=/build/vmlinux \
    make clean && \
    LIBBPF_SRC=/build/bpftool/libbpf/src \
    BPFTOOL_SRC=/build/bpftool/src \
    VMLINUX_DIR=/build/vmlinux \
    make sslsniff && \
    cp sslsniff /usr/local/bin/

# =============================================================================
# Stage 2: Build Rust sensor with embedded sslsniff
# =============================================================================
FROM rust:latest AS builder

RUN apt-get update && apt-get install -y \
    build-essential \
    pkg-config \
    libssl-dev \
    lld \
    && rm -rf /var/lib/apt/lists/*

COPY --from=libbpf-builder /usr/local/bin/sslsniff /usr/local/bin/sslsniff

WORKDIR /build
COPY oisp-sensor/ ./

RUN mkdir -p frontend/out && echo '<!DOCTYPE html><html><body>Stub</body></html>' > frontend/out/index.html

RUN --mount=type=cache,target=/usr/local/cargo/registry \
    --mount=type=cache,target=/build/target \
    RUSTFLAGS="-C link-arg=-fuse-ld=lld" \
    cargo build --release -p oisp-sensor --no-default-features --features tui && \
    cp target/release/oisp-sensor /usr/local/bin/oisp-sensor

# =============================================================================
# Stage 3: Build sensor Docker image (exported as tar for CI to load)
# =============================================================================
FROM debian:trixie-slim AS sensor-image

RUN apt-get update && apt-get install -y \
    ca-certificates \
    libssl3 \
    libelf1 \
    zlib1g \
    openssl \
    procps \
    curl \
    && rm -rf /var/lib/apt/lists/*

RUN useradd -m -s /bin/bash -u 1000 oisp

COPY --from=builder /usr/local/bin/oisp-sensor /usr/local/bin/

RUN mkdir -p /var/lib/oisp /var/log/oisp /etc/oisp && \
    chown -R oisp:oisp /var/lib/oisp /var/log/oisp

ENTRYPOINT ["oisp-sensor"]
CMD ["record", "--output", "/output/events.jsonl"]

# =============================================================================
# Stage 4: Test runner - lightweight, uses host's Docker/k3d
# =============================================================================
FROM ubuntu:24.04

# Install dependencies
RUN apt-get update && apt-get install -y \
    bash \
    curl \
    jq \
    python3 \
    docker.io \
    && rm -rf /var/lib/apt/lists/*

# Install kubectl
RUN curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" && \
    chmod +x kubectl && \
    mv kubectl /usr/local/bin/

# Install k3d
RUN curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash

# Copy sensor binary for reference
COPY --from=builder /usr/local/bin/oisp-sensor /usr/local/bin/

# Copy test files
WORKDIR /test
COPY oisp-cookbook/openshift/daemonset/manifests/ ./manifests/
COPY oisp-cookbook/openshift/daemonset/expected-events.json .
COPY --chmod=755 oisp-cookbook/shared/scripts/validate.py /scripts/

# Save sensor image rootfs for building
COPY --from=sensor-image / /sensor-rootfs/

# Test script
COPY <<'EOF' /test/run-test.sh
#!/bin/bash
set -e

echo "=== OISP OpenShift DaemonSet E2E Test ==="
echo ""
echo "Note: Running with k3d (OpenShift SCCs are not enforced in k3d,"
echo "      but manifests and RBAC are validated)"
echo ""

# Create output dir
mkdir -p /output

# Check prerequisites
echo "Checking prerequisites..."
echo "kubectl version: $(kubectl version --client -o json 2>/dev/null | jq -r '.clientVersion.gitVersion' 2>/dev/null || echo 'unknown')"
echo "k3d version: $(k3d version 2>/dev/null | head -1 || echo 'not installed')"
echo ""

# Check API key
if [ -z "$OPENAI_API_KEY" ]; then
    echo "ERROR: OPENAI_API_KEY not set"
    exit 1
fi

# Check if docker is available (should be mounted from host)
echo "Docker status:"
if docker info >/dev/null 2>&1; then
    docker info 2>/dev/null | grep -E "(Server Version|Storage Driver)" || true
else
    echo "ERROR: Docker not available. Make sure docker socket is mounted."
    exit 1
fi
echo ""

# Build sensor image from the rootfs we copied
echo "Building sensor image for k3d..."
cat > /tmp/Dockerfile.sensor << 'DOCKERFILE'
FROM scratch
COPY . /
ENTRYPOINT ["oisp-sensor"]
CMD ["record", "--output", "/output/events.jsonl"]
DOCKERFILE

docker build -t oisp-sensor:test-local -f /tmp/Dockerfile.sensor /sensor-rootfs/

echo "Sensor image built successfully"
docker images oisp-sensor:test-local
echo ""

# Create k3d cluster
CLUSTER_NAME="oisp-openshift-test-$$"
echo "Creating k3d cluster: $CLUSTER_NAME"
k3d cluster create "$CLUSTER_NAME" --wait

# Cleanup on exit
cleanup() {
    echo ""
    echo "Cleaning up..."
    k3d cluster delete "$CLUSTER_NAME" 2>/dev/null || true
}
trap cleanup EXIT

# Import sensor image into k3d
echo "Importing sensor image into k3d..."
k3d image import oisp-sensor:test-local -c "$CLUSTER_NAME"
echo ""

# Patch daemonset to use local image
echo "Generating DaemonSet manifest with local image..."
sed 's|ghcr.io/oximyhq/sensor:latest|oisp-sensor:test-local|g; s/imagePullPolicy: Always/imagePullPolicy: Never/g' \
    manifests/daemonset.yaml > /tmp/daemonset-local.yaml

# Deploy manifests (skip SCC as k3d doesn't support it)
echo "Deploying namespace..."
kubectl apply -f manifests/namespace.yaml

echo "Deploying ServiceAccount and RBAC..."
kubectl apply -f manifests/service-account.yaml

echo "Deploying ConfigMap..."
kubectl apply -f manifests/configmap.yaml

# Note: SCC (scc.yaml) is skipped as k3d doesn't support OpenShift SCCs
echo "Skipping SCC (OpenShift-specific, not supported in k3d)"

echo "Deploying sensor DaemonSet..."
kubectl apply -f /tmp/daemonset-local.yaml

# Wait for sensor to be ready
echo "Waiting for sensor pods (timeout: 120s)..."
if ! kubectl wait --for=condition=ready pod -n oisp-sensor -l app.kubernetes.io/name=oisp-sensor --timeout=120s; then
    echo "ERROR: Sensor pod failed to become ready"
    echo "Pod status:"
    kubectl get pods -n oisp-sensor -o wide
    echo "Pod description:"
    kubectl describe pods -n oisp-sensor -l app.kubernetes.io/name=oisp-sensor
    echo "Pod logs:"
    kubectl logs -n oisp-sensor -l app.kubernetes.io/name=oisp-sensor --tail=50 || true
    exit 1
fi

echo "Sensor pod is ready!"
echo ""

# Create API key secret
echo "Creating API key secret..."
kubectl create secret generic openai-api-key \
    -n oisp-sensor \
    --from-literal=OPENAI_API_KEY="$OPENAI_API_KEY"

# Deploy test application
echo "Deploying test application..."
kubectl apply -f manifests/test-app.yaml

# Wait for test app to complete
echo "Waiting for test app to complete (timeout: 180s)..."
if ! kubectl wait --for=condition=complete job/test-app -n oisp-sensor --timeout=180s; then
    echo "ERROR: Test app job failed or timed out"
    echo "Job status:"
    kubectl get jobs -n oisp-sensor
    echo "Pod status:"
    kubectl get pods -n oisp-sensor -l app.kubernetes.io/name=test-app
    echo "Test app logs:"
    kubectl logs -n oisp-sensor -l app.kubernetes.io/name=test-app --tail=50 || true
    exit 1
fi

echo "Test app completed!"
echo ""

# Wait for sensor to process events
echo "Waiting for sensor to process events..."
sleep 10

# Extract events from sensor pod
echo "Extracting captured events..."
SENSOR_POD=$(kubectl get pods -n oisp-sensor -l app.kubernetes.io/name=oisp-sensor -o jsonpath='{.items[0].metadata.name}')

if ! kubectl cp "oisp-sensor/$SENSOR_POD:/output/events.jsonl" /output/events.jsonl 2>/dev/null; then
    echo "No events file yet, checking sensor status..."
    echo "Sensor logs:"
    kubectl logs -n oisp-sensor "$SENSOR_POD" --tail=30 || true
    echo "Output directory contents:"
    kubectl exec -n oisp-sensor "$SENSOR_POD" -- ls -la /output/ 2>/dev/null || true
    touch /output/events.jsonl
fi

# Show what was captured
echo ""
echo "Events captured:"
if [ -s /output/events.jsonl ]; then
    wc -l /output/events.jsonl
    head -5 /output/events.jsonl
else
    echo "(no events captured)"
fi

# Show sensor logs
echo ""
echo "=== Sensor Logs ==="
kubectl logs -n oisp-sensor "$SENSOR_POD" --tail=30 || echo "(no logs)"
echo "=== End Sensor Logs ==="
echo ""

# Validate events
echo "Validating captured events..."
python3 /scripts/validate.py /output/events.jsonl expected-events.json
RESULT=$?

echo ""
if [ $RESULT -eq 0 ]; then
    echo "=== TEST PASSED ==="
else
    echo "=== TEST FAILED ==="
    echo ""
    echo "All captured events:"
    cat /output/events.jsonl 2>/dev/null || echo "(none)"
    echo ""
    echo "Test app logs:"
    kubectl logs -n oisp-sensor -l app.kubernetes.io/name=test-app --tail=30 || true
fi

exit $RESULT
EOF

RUN chmod +x /test/run-test.sh

CMD ["/test/run-test.sh"]
